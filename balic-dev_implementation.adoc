////
Purpose
-------
In the "Base" directory, this section is a placeholder which is to be
overwritten by implementation details specific to the product or products being
delivered.

If "TODO" appears in your document after the init script has been run, then
your product directory is missing a corresponding "implementation.adoc" which
should be created to provide a basic implementation framework for that product.
////

:imagesdir: images

== Create new namespace in Openshift

  $oc new-project rhsso-np

==  Enable annotation on namespace for node selector
  $oc annotate namespace rhsso-np openshift.io/node-selector=node-role.kubernetes.io/worker=

== Red Hat DataGrid Installation using Operator

=== Login into Openshift Webconsole with admin privileges.

Navigate to Menu-> operator hub ->Click on search->Search Red Hat Datagrid -> Install operator->approval strategy->automatic



image::rhdg-operator.PNG[]

=== Verify the Installed operator status

image::rhdg-installed.PNG[]

=== Create Infinispan cluster

Navigate to Menu-> click Installed Operator-> Red Hat Data-grid->Infinispan Cluster -> Create infnispan -> create

image::infinispan-cluster.PNG[]

=== Edit ConfigMap for disabling the hotrod and rest security for RHSSO connectivity with RHDG.
Add below endpoints in DataGrid config map to disable the hotrod and rest security for RHSSO connectivity with RHDG.

[source,yaml]
----
endpoints:
  hotrod:
    auth: false
  rest:
    auth: false
----

Get the config map name using openshift cli command


 $ oc get cm

=== Edit configMap

[source,yaml]
----
$ oc edit configmap rhsso-infinispan-configuration

apiVersion: v1
data:
  infinispan.yaml: |
    clusterName: rhsso-infinispan
    jgroups:
      transport: tcp
      dnsPing:
        query: rhsso-infinispan-ping.rhdg.svc.cluster.local
    keystore:
      path: ""
      password: ""
      alias: ""
    xsite:
      address: ""
      name: ""
      port: 0
      backups: []
    logging:
      categories: {}
    endpoints:
      hotrod:
        auth: false
      rest:
        auth: false
kind: ConfigMap
metadata:
  creationTimestamp: 2020-06-27T04:49:18Z
  labels:
    app: infinispan-configmap-configuration
    clusterName: rhsso-infinispan
    infinispan_cr: rhsso-infinispan
  name: rhsso-infinispan-configuration
  namespace: rhdg
  ownerReferences:
  - apiVersion: infinispan.org/v1
    blockOwnerDeletion: true
    controller: true
    kind: Infinispan
    name: rhsso-infinispan
    uid: a2103ccb-0041-4069-b399-05bdd5f0c015
  resourceVersion: "3105968"
  selfLink: /api/v1/namespaces/rhdg/configmaps/rhsso-infinispan-configuration
  uid: b6c56d5d-b14c-43bf-a961-070fd13af776

----




=== Reflect the config map changes using cli.

To reflect the changes of configMap we need to scale down and scale up the replicas in infinispan yaml to spec.replicas: 0
We can do it either cli or Webconsole.

NOTE: Take reference from below configuration

==== Get the infinispan kind

 $ oc get infinispan
 NAME                 AGE
 rhsso-infinispan   18h

==== Edit the infinispan


[source,yaml]
----
$ oc edit infinispan rhsso-infinispan

apiVersion: infinispan.org/v1
kind: Infinispan
metadata:
 creationTimestamp: 2020-07-22T12:39:51Z
 finalizers:
 - finalizer.infinispan.org
 generation: 6
 name: rhsso-infinispan
 namespace: rhsso
 resourceVersion: "2799133"
 selfLink: /apis/infinispan.org/v1/namespaces/rhsso/infinispans/rhsso-infinispan
 uid: 79bcca16-7a80-4f1a-a992-656d2fe243e2
spec:
 container:
   cpu: 500m
   memory: 512Mi
 replicas: 3
 security:
   endpointEncryption:
     certSecretName: ""
     certServiceName: ""
     type: ""
   endpointSecretName: rhsso-infinispan-generated-secret
 service:
   type: Cache
status:
 conditions:
 - message: 'View: rhsso-infinispan-0-24317'
   status: "True"
   type: wellFormed
 - message: ""
   status: "False"
   type: stopping
 - message: ""
   status: "False"
   type: gracefulShutdown
 security:
   endpointEncryption:
     certSecretName: ""
     certServiceName: ""
     type: ""
   endpointSecretName: rhsso-infinispan-generated-secret
 statefulSetName: rhsso-infinispan

----


=== Scale Up the Replicas of infinispan Using Webconsole

Navigate to Installed Operators -> DataGrid -> Infinispan Cluster -> rhsso-infinispan -> Yaml

Increase the number of replicas in spec.replicas: 3

NOTE: take reference from below image.

image::infinispan-replicas.PNG[]


=== Create Caches using custom template

To create caches in DataGrid we need to create custom template and using that we can create caches for data persistent.

TIP: To get the IP and Name of the pods ($oc get pods -o wide)



1) Login into one of the Red Hat Data Grid Pods

 $oc rsh rhsso-infinispan-0


2) Create caches.xml file inside pod data directory

TIP: rhsso-infinispan-0 pod data directory is persistent storage


[source,yaml]
----
sh-4.4$ vi server/data/caches.json

    {
     "replicated-cache": {
       "mode": "SYNC",
       "start": "EAGER",
       "batching": false,
       "state-transfer": {
          "timeout": 60000
       },
       "transaction":
       {  "mode": "NONE",
           "locking" : "PESSIMISTIC"
       },
       "encoding": {
         "media-type": "application/x-protostream"
         },
       "locking": {
        "acquire-timeout": 0
       },
       "statistics" : true
     }
    }
----

3) Create caches using above template file.

Login into infinispan server using cli

TIP: sh-4.4$ ./bin/cli.sh -c pod_ip:rhdg_port

....
sh-4.4$ ./bin/cli.sh -c 10.131.0.28:11222
[rhsso-infinispan-0-24317@infinispan//containers/default]> create cache --file=server/data/caches.json work
[rhsso-infinispan-0-24317@infinispan//containers/default]> create cache --file=server/data/caches.json loginFailures
[rhsso-infinispan-0-24317@infinispan//containers/default]> create cache --file=server/data/caches.json clientSessions
[rhsso-infinispan-0-24317@infinispan//containers/default]> create cache --file=server/data/caches.json sessions
[rhsso-infinispan-0-24317@infinispan//containers/default]> create cache --file=server/data/caches.json offlineSessions
[rhsso-infinispan-0-24317@infinispan//containers/default]> create cache --file=server/data/caches.json offlineClientSessions
[rhsso-infinispan-0-24317@infinispan//containers/default]> create cache --file=server/data/caches.json actionTokens
....


To get the list of caches

 [rhsso-infinispan-0-24317@infinispan//containers/default]> ls caches
    loginFailures
    ___script_cache
    ___protobuf_metadata
    clientSessions
    work
    offlineClientSessions
    default
    sessions
    actionTokens
    offlineSessions

NOTE: We do not need to create the caches in every pod as every pod is in cluster mode so one pod will replicate the all caches among all 3 pods.


== Red Hat SSO deployment and integration With RHDG

=== Creating HTTPS and JGroups Keystores, and Truststore for the Red Hat Single Sign-On Server
The Red Hat Single Sign-On application templates using passthrough TLS termination require:

 * An HTTPS keystore used for encryption of https traffic,
 * The JGroups keystore used for encryption of JGroups communications between nodes in the cluster, and
 * Red Hat Single Sign-On server truststore used for securing the Red Hat Single Sign-On requests

TIP: The openssl toolkit is used to generate a CA certificate to sign the HTTPS keystore, and create a truststore for the Red Hat Single Sign-On server. keytool is then utilized to the generate self-signed certificates for these keystores.

 * Create the HTTPS keystore:

i). Generate a CA certificate for the HTTPS keystore. Provide redhat as the certificate password.

  $openssl req -new -newkey rsa:4096 -x509 -keyout xpaas.key -out xpaas.crt -days 365 -subj "/CN=xpaas-sso.ca"

ii). Create KeyPair and store in Keystore. Provide redhat as the keystore password

   $keytool -genkeypair -keyalg RSA -keysize 2048 -dname "CN=secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com" -alias rhsso -keystore keystore.jks

iii). Generate the certificate sign request using keystore. Provide the same password (redhat).

  $keytool -certreq -keyalg rsa -alias rhsso -keystore keystore.jks -file sso.csr

iv).Sign the Server Certificate by self signed CA. Provide redhat as the keystore password. Reply
 yes to Trust this certificate? [no]: question.

 $openssl x509 -req -CA xpaas.crt -CAkey xpaas.key -in sso.csr -out sso.crt -days 365 -CAcreateserial

v). Import the Server certificate into a new Red Hat Single Sign-On server truststore. Provide redhat as the
 truststore password. Reply yes to Trust this certificate? [no]: question:

  $keytool -import -file sso.crt -alias sso -keystore keystore.jks

vi). Import the CA certificate into a new Red Hat Single Sign-On server truststore. Provide redhat as the
 truststore password. Reply yes to Trust this certificate? [no]: question:

  $keytool -import -file xpaas.crt -alias xpaas.ca -keystore truststore.jks

vii). Generate a secure key for the JGroups keystore. Provide redhat as the keystore password.

  $keytool -genseckey -alias secret-key -storetype JCEKS -keystore jgroups.jceks


=== Create the secrets

Create the secrets for the HTTPS and JGroups keystores. Truststore, generated in the previous steps.

  $oc create secret generic rhsso-secret --from-file=keystore.jks --from-file=jgroups.jceks --from-file=truststore.jks

=== Link secret to your project

Link these secrets to the default service account, which is used to run Red Hat Single Sign-On pods.

  $oc secrets link default rhsso-secret

=== Deploying the Red Hat Single Sign-On Image using the Application Template.

 1. clone template from github.
  $git clone https://github.com/jboss-container-images/Red Hat-sso-7-openshift-image.git

 2. Change directory to templates
  $cd Red Hat-sso-7-openshift-image/templates

 3. Run the following commands to update the core set of Red Hat Single Sign-On 7.4.1.GA resources for OpenShift in the openshift project.

  $oc create -f sso74-https.json -n openshift

NOTE: output : template.template.openshift.io/sso74-https created

=== Import RHSSO image from Red Hat repository

 $oc import-image rh-sso-7/sso74-openshift-rhel8 --from=registry.Red Hat.io/rh-sso-7/sso74-openshift-rhel8 --confirm -n openshift

=== Verify image in openshift namespace

 $oc get is sso74-openshift-rhel8  -n openshift
     NAME                    IMAGE REPOSITORY                                                                   TAGS      UPDATED
     sso74-openshift-rhel8   image-registry.openshift-image-registry.svc:5000/openshift/sso74-openshift-rhel8   latest    43 seconds ago

=== Create RHSSO configuration for datasource, caches and RHDG connectivity using cli commands.
1. Create an empty directory rhsso_rhdg in any location.
2. Create a new file rhsso_rhdg/sso-extensions.cli file in this directory with the following contents. Update the values of the variables such as DB_JDBC_URL and Remote-cache host (host=rhsso-infinispan) according to the deployment needs.

 $ cat sso-extensions.cli
    batch
    set DB_DRIVER_NAME=postgresql
    set DB_USERNAME=rhssoadmin
    set DB_PASSWORD=Ocprhsso321
    set DB_DRIVER=org.postgresql.Driver
    set DB_XA_DRIVER=org.postgresql.xa.PGXADataSource
    set DB_JDBC_URL="jdbc:postgresql://rhssodb.ocplife-np.bajajallianz.com:5432/rhssodb"
    set DB_EAP_MODULE=org.postgresql
    /subsystem=datasources/data-source=KeycloakDS:remove()
    /subsystem=datasources/data-source=KeycloakDS:add( \
    jndi-name=java:jboss/datasources/KeycloakDS, \
    enabled=true, \
    use-java-context=true, \
    connection-url=$DB_JDBC_URL, \
    driver-name=$DB_DRIVER_NAME, \
    user-name=$DB_USERNAME, \
    password=$DB_PASSWORD \
    )
    /subsystem=datasources/data-source=KeycloakDS:write-attribute(name=min-pool-size,value=2)
    /subsystem=datasources/data-source=KeycloakDS:write-attribute(name=max-pool-size,value=10)
    /subsystem=datasources/data-source=KeycloakDS:write-attribute(name=valid-connection-checker-class-name,value=org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker)
    /subsystem=datasources/data-source=KeycloakDS:write-attribute(name=validate-on-match,value=true)
    /subsystem=datasources/data-source=KeycloakDS:write-attribute(name=exception-sorter-class-name,value=org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter)
    /subsystem=datasources/data-source=KeycloakDS:write-attribute(name=new-connection-sql,value=select 1)
    /subsystem=jgroups/stack=tcp/transport=TCP:write-attribute(name=site,value=dev-site1)
    /subsystem=infinispan/cache-container=keycloak:write-attribute(name=module, value=org.keycloak.keycloak-model-infinispan)
    /socket-binding-group=standard-sockets/remote-destination-outbound-socket-binding=remote-cache/:add(host=rhsso-infinispan,port=${remote.cache.port:11222},fixed-source-port=false)
    /subsystem=infinispan/cache-container=keycloak/replicated-cache=work/store=remote:add(cache=work,remote-servers=[remote-cache],fetch-state=false,passivation=false,preload=false,purge=false,shared=true,properties={rawValues=true,marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory,protocolVersion=2.9})
    /subsystem=infinispan/cache-container=keycloak/distributed-cache=sessions/store=remote:add(cache=sessions,remote-servers=[remote-cache],fetch-state=false,passivation=false,preload=false,purge=false,shared=true,properties={rawValues=true,marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory,protocolVersion=2.9})
    /subsystem=infinispan/cache-container=keycloak/distributed-cache=offlineSessions/store=remote:add(cache=offlineSessions,remote-servers=[remote-cache],fetch-state=false,passivation=false,preload=false,purge=false,shared=true,properties={rawValues=true,marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory,protocolVersion=2.9})
    /subsystem=infinispan/cache-container=keycloak/distributed-cache=clientSessions/store=remote:add(cache=clientSessions,remote-servers=[remote-cache],fetch-state=false,passivation=false,preload=false,purge=false,shared=true,properties={rawValues=true,marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory,protocolVersion=2.9})
    /subsystem=infinispan/cache-container=keycloak/distributed-cache=offlineClientSessions/store=remote:add(cache=offlineClientSessions,remote-servers=[remote-cache],fetch-state=false,passivation=false,preload=false,purge=false,shared=true,properties={rawValues=true,marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory,protocolVersion=2.9})
    /subsystem=infinispan/cache-container=keycloak/distributed-cache=loginFailures/store=remote:add(cache=loginFailures,remote-servers=[remote-cache],fetch-state=false,passivation=false,preload=false,purge=false,shared=true,properties={rawValues=true,marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory,protocolVersion=2.9})
    /subsystem=infinispan/cache-container=keycloak/distributed-cache=actionTokens/store=remote:add(cache=actionTokens,remote-servers=[remote-cache],fetch-state=false,passivation=false,preload=false,purge=false,shared=true,properties={rawValues=true,marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory,protocolVersion=2.9})
    /subsystem=infinispan/cache-container=keycloak/distributed-cache=actionTokens/memory=object:write-attribute(name=size,value=-1)
    /subsystem=infinispan/cache-container=keycloak/distributed-cache=actionTokens/component=expiration:add(interval=300000,max-idle=-1)
    run-batch

3.  Create a new Dockerfile file in this directory with the following contents.

 $ cat Dockerfile
    # Creating new image using exsting image
    FROM image-registry.openshift-image-registry.svc:5000/openshift/sso74-openshift-rhel8
    USER root
    # Copy the module creation cli commands which will execute in embeded-server mode
    COPY sso-extensions.cli /opt/eap/extensions/


=== Create New Build for RHSSO custom image with the below command.

 $oc new-build --name=sso74 --binary --strategy=docker -n openshift

=== Start Build for creating custom image and pushing into opeshift namespace.

NOTE: From directory (--from-dir) could be any path where your docker file exists. In these steps rhsso_rhdg directory is used to store extensions-cli as well as dockerfile.

 $oc start-build sso74 --from-dir=rhsso_rhdg --follow -n openshift

=== Edit RHSSO template with custom image which was created in earlier step.

Edit the template using below commands.

 $oc edit template sso74-https -n openshift

Replace the template imageStream name: sso74-openshift-rhel8:7.4 with your custom image name.

[source,yaml]
----
    triggers:
       from:
          kind: ImageStreamTag
          name: sso74:latest
          namespace: ${IMAGE_STREAM_NAMESPACE}
----


=== Deploy the application with template using the parameters.

 $oc new-app --name=nonprod-sso \
 --template=sso74-https \
 -p HTTPS_SECRET="rhsso-secret" \
 -p HTTPS_KEYSTORE="keystore.jks" \
 -p HTTPS_NAME="rhsso" \
 -p HTTPS_PASSWORD="Red Hat" \
 -p JGROUPS_ENCRYPT_SECRET="rhsso-secret" \
 -p JGROUPS_ENCRYPT_KEYSTORE="jgroups.jceks" \
 -p JGROUPS_ENCRYPT_NAME="secret-key" \
 -p JGROUPS_ENCRYPT_PASSWORD="Red Hat" \
 -p SSO_ADMIN_USERNAME="Username" \
 -p SSO_ADMIN_PASSWORD="******" \
 -p SSO_REALM="openshift"  \
 -p SSO_TRUSTSTORE="truststore.jks"  \
 -p SSO_TRUSTSTORE_PASSWORD="Red Hat" \
 -p SSO_TRUSTSTORE_SECRET="rhsso-secret"

=== Verify the output.
 Output:
  --> Deploying template "openshift/sso74-https" to project rhsso-np
    Red Hat Single Sign-On 7.4 on OpenJDK (Ephemeral with passthrough TLS)
    ---------
    An example application based on RH-SSO 7.4 on OpenJDK image. For more information about using this template, see https://github.com/jboss-container-images/Red Hat-sso-7-openshift-image/tree/sso74-dev/docs.
    A new RH-SSO service has been created in your project. The admin username/password for accessing the master realm via the RH-SSO console is rhssoadmin/Balic@123. Please be sure to create the following secrets: "rhsso-secret" containing the keystore.jks file used for serving secure content; "rhsso-secret" containing the jgroups.jceks file used for securing JGroups communications; "rhsso-secret" containing the truststore.jks file used for securing RH-SSO requests.
   * With parameters:
     * Application Name=sso
     * Custom http Route Hostname=
     * Custom https Route Hostname=
     * Custom RH-SSO Server Hostname=
     * Server Keystore Secret Name=rhsso-secret
     * Server Keystore Filename=keystore.jks
     * Server Keystore Type=
     * Server Certificate Name=rhsso
     * Server Keystore Password=Red Hat
     * Datasource Minimum Pool Size=
     * Datasource Maximum Pool Size=
     * Datasource Transaction Isolation=
     * JGroups Secret Name=rhsso-secret
     * JGroups Keystore Filename=jgroups.jceks
     * JGroups Certificate Name=secret-key
     * JGroups Keystore Password=Red Hat
     * JGroups Cluster Password=xTW5TJmv # generated
     * ImageStream Namespace=openshift
     * RH-SSO Administrator Username=Username
     * RH-SSO Administrator Password=*****
     * RH-SSO Realm=openshift
     * RH-SSO Service Username=
     * RH-SSO Service Password=
     * RH-SSO Trust Store=truststore.jks
     * RH-SSO Trust Store Password=Red Hat
     * RH-SSO Trust Store Secret=rhsso-secret
     * Container Memory Limit=1Gi
  --> Creating resources ...
   service "sso" created
   service "secure-sso" created
   service "sso-ping" created
   route.route.openshift.io "sso" created
   route.route.openshift.io "secure-sso" created
   deploymentconfig.apps.openshift.io "sso" created
  --> Success
   Access your application via route 'sso-rhsso-np.apps.ocplife-np.bajajallianz.com'
   Access your application via route 'secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com'
   Run 'oc status' to view your app.


=== Identify the name of the route for the Red Hat Single Sign-On service.
 $oc get route
 NAME          HOST/PORT
 secure-sso    secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com

=== Delete/Edit the defaults route for passthrough TLS termination.

  $oc delete route secure-sso sso

=== Recreate passthrough route to access the application on secure port 8443 only.

Navigate to Networking -> Routes ->  Create Route

image::create-route.PNG[]

  * Name: secure Route
  * Hostname: blank (Not available now)
  * Path: /
  * Service: sso-secure
  * Target-port: 8443->8443(TCP)
  * Secure route: check
  * TLS Termination: Passthrough
  * Insecure Traffic: None

=== Login into RHSSO appliction

Get the route name from below command.

 $oc get route
 NAME          HOST/PORT
 secure-sso    secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com

Copy route url into browser and login with the credentials given while deploying app.

* RH-SSO Administrator Username: username
* RH-SSO Administrator Password: password


== Openshift Authentication with RHSSO

To authenticate Openshift with RHSSO need the following details.

 1) Users from RHSSO realm.
 2) RHSSO Openshift client which will authenticate the Openshift cluster login users.
 3) Groups from openshift to validate users.
 4) Policy from openshift to restrict user roles.

=== Create secret for RHSSO credentials

Copy secret from credentials which is available in Openshift realm and create secret for OAuth.

image::client-credentials.PNG[]

Create secret in openshift from copied credentials which will be used by openshift client authentication.

 $oc create secret generic ssoauth-secret --from-literal=clientSecret=7ddbd3a5-0611-4abb-bca6-a73f18b2a8a1 -n openshift-config

=== Create client in openshift namespace

Navigate to Clients-> new client

 * ClientID: openshift-auth (client name)
 * Name: Openshift Authentication
 * Client protocol: openid-connect
 * Access protocol: confidential
 * Root url: openshift console url
 * Valid Redirect url: auth2callback url

image::openshift-client.PNG[]



=== Edit OAuth in Openshift-authentication namespace

Add oauth identityProviders in Openshift-authentication namespace oauth kind. Below configuration starts from mapping method will be added into OAuth kind.

[source,yaml]
----
 - mappingMethod: claim
    name: ssoauth
    ....
    ....
    type: OpenID

----

[source,yaml]

----
$oc edit oauth cluster -n openshift-authentication

apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
annotations:
  kubectl.kubernetes.io/last-applied-configuration:
    {"apiVersion":"config.openshift.io/v1","kind":"OAuth","metadata":{"annotations":{},"name":"cluster"},"spec":{"identityProviders":[{"htpasswd":{"fileData":{"name":"htpass-secret"}},"mappingMethod":"claim","name":"htpasswd_provider","type":"HTPasswd"}]}}
  release.openshift.io/create-only: 'true'
creationTimestamp: '2020-05-20T10:57:40Z'
generation: 2
name: cluster
resourceVersion: '348966'
selfLink: /apis/config.openshift.io/v1/oauths/cluster
uid: 5ed0157b-a5e8-4ba7-aedd-dc63d668ce31
spec:
identityProviders:
  - htpasswd:
      fileData:
        name: htpass-secret
    mappingMethod: claim
    name: htpasswd_provider
    type: HTPasswd
  - mappingMethod: claim
    name: ssoauth
    openID:
      ca:
        name: sso-config-map
      claims:
        email:
        - email
        name:
        - given_name
        - name
        preferredUsername:
        - preferred_username
        - email
      clientID: openshift-auth
      clientSecret:
        name: ssoauth-secret
      extraAuthorizeParameters:
        include_granted_scopes: "true"
    extraScopes:
    - email
    - profile
    issuer: https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/openshift
  type: OpenID

----

TIP: To Verify the issuer in rhsso use the curl
  $curl -k https://https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/openshift/.well-known/openid-configuration

TIP: Output will appear like this:
  {"issuer":"https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/openshift" ......}



=== Create User Federation in rhsso to import users from AD.

To create User Federation the following points are mendatory.

 * Display Name: AD-RODC
 * Priority: 0
 * Import Users: optional (if do not want to import users in rhsso db)
 * Edit Mode: Readonly (for no changes into AD database)
 * User Object Classes: Schema class (User attribute class)
 * ConnectionUrl: AD server url with PORT
 * Use DN: User OU name for importing Users
 * Bind DN: Ad credentials for accessing the AD.
 * Bind Credentials: Password
 * Sync settings: Next time sync time for full sync or changed user sync.


image::userfederation.PNG[]


=== Create Group Mapper in RHDS user Federation

Group mappers are used to create user and group membership which is imported from AD into RHSSO. To create group mapper below steps are defined.

 * LDAP Group DN: list of ou's which are defined as groups of users in AD.
 * Group Name Ldap attribute: cn
 * Memeber LDAP attribute: member that is used to store users into Group OU.
 * LDAP filter: For specific group import
 * Mode: readonly (it will read users group membership from AD)
 * User Groups Retrieve Strategy: Get users from member attribute which is defined into USER class.
 * Member-Of LDAP Attribute: It is user role retrieve strategy defind in User schema.
 * Finally: Sync ldap group to Keycloak


image::openshift-mapper.PNG[]


=== Verify the imported Users in RHSSO

Navigate to Users -> View all Users

image::users.PNG[]

=== Verify the Groups in RHSSO

To verify the imported groups in RHSSO

Navigate to Groups -> View all Groups

image::groups.PNG[]

=== Create Groups in Openshift
A new group balic  is created for openshift authentication with RHSSO.

  $oc adm groups new balic

=== Adding users into Group.

Add the Openshift realm all users into balic group.

  $oc adm groups add-users balic test1 test2

=== Adding policies to users.

Policies are added to restrict the usage of all users who will login into openshift cluster.

NOTE: Admin policy: If a User is assigned with admin role then he will be Administrator of his own namespace with all privileges.

  $oc adm policy add-role-to-group admin balic -n rhsso-np



== RHDS master-master replication

=== RHDS11 Master-Master Replication over Secure port(636)

For initial configuration need to subscribe the both VM with Red Hat subscription account.

=== Subscribe the VM with Red Hat subscription Account

=== list all subscription

List all subscriptions and verify the Developer Subscription name.

      subscription-manager list --available --all
      Subscription Name:   Red Hat Enterprise Linux Developer Suite
      Provides:            ...
                          Red Hat Directory Server
                          ...
      Pool ID:             5ab6a8df96b03fd30aba9a9c58da57a1
      Available:           1


=== Attach pool id

Attach the subscription-manager with Developer subscription pool id.

 $ subscription-manager attach --pool=5ab6a8df96b03fd30aba9a9c58da57a1
    Successfully attached a subscription for: Red Hat Enterprise Linux Developer.

=== Enable the repository.

Enable the dirsrv-11-for-rhel-8-x86_64-rpms repository:

  $ subscription-manager repos --enable=dirsrv-11-for-rhel-8-x86_64-rpms
    Repository 'dirsrv-11-for-rhel-8-x86_64-rpms' is enabled for this system.

=== Install the Red Hat-ds:11 module in both Servers:

Before start installation update the VM's.

 $ yum update

Install the rhds-module

 $ yum module install Red Hat-ds:11



For interactive installer, we need to set the following settings:

    * Host name of the system
    * Name of the instance
    * LDAP port number
    * DN of the directory manager account
    * Password of the directory manager account
    * Optional creation of a database suffix

=== Master node 1 configuration

 $ dscreate interactive
  Install Directory Server (interactive mode)
  =============================
  Enter system's hostname [L7SRL2RDS01]: L7SRL2RDS01
  Enter the instance name [rhds1]: rhds1
  Enter port number [389]: 389
  Create self-signed certificate database [yes]: no
  Enter Directory Manager DN [cn=Directory Manager]: cn=Directory Manager
  Enter the Directory Manager password: 12345678
  Confirm the Directory Manager Password: 12345678
  Enter the database suffix (or enter "none" to skip) [dc=rhds1,dc=bajajallianz,dc=in]:dc=bajajallianz,dc=in
  Create sample entries in the suffix [no]: no
  Create just the top suffix entry [no]: no
  Do you want to start the instance after the installation? [yes]: yes
  Are you ready to install? [no]: yes
  Starting installation...
  Completed installation for rhds1



=== Master node2 configuration

 $ dscreate interactive
  Install Directory Server (interactive mode)
  =============================
  Enter system's hostname [L7SRL2RDS02]: L7SRL2RDS02
  Enter the instance name [rhds2]: rhds2
  Enter port number [389]: 389
  Create self-signed certificate database [yes]: no
  Enter Directory Manager DN [cn=Directory Manager]: cn=Directory Manager
  Enter the Directory Manager password: 12345678
  Confirm the Directory Manager Password: 12345678
  Enter the database suffix (or enter "none" to skip) [dc=rhds2,dc=bajajallianz,dc=in]:dc=bajajallianz,dc=in
  Create sample entries in the suffix [no]: no
  Create just the top suffix entry [no]: no
  Do you want to start the instance after the installation? [yes]: yes
  Are you ready to install? [no]: yes
  Starting installation...
  Completed installation for rhds2





=== Create root certificates for SSL verification
==== Create Root Key
this is the key used to sign the certificate requests, anyone holding this can sign certificates on your behalf.

 $ openssl genrsa -des3 -out rootCA.key 4096

==== Create and self sign the Root Certificate

Here we used our root key to create the root certificate that needs to be distributed in all the servers that have to trust us.

 $openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.crt

==== Create rhds1 tls certificates

==== Create the certificate key

 $ openssl genrsa -out rhds1.key 2048

==== Create the signing (csr)

 $ openssl req -new -key rhds1.key -out rhds1.csr

==== Generate the certificate using the rhds1 csr and key along with the CA Root key

 $ openssl x509 -req -in rhds1.csr -CA rootCA.crt -CAkey certs/rootCA.key -CAcreateserial -out rhds1.crt -days 500 -sha256


==== verify certificates content

    openssl req -in rhds1.csr -noout -text

==== Create rhds2 tls certificates

==== Create the certificate key

 $openssl genrsa -out rhds2.key 2048

==== Create the signing (csr)

 $openssl req -new -key rhds2.key -out rhds2.csr

==== Generate the certificate using the rhds1 csr and key along with the CA Root key

 $openssl x509 -req -in rhds2.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out rhds2.crt -days 500 -sha256

=== Copy the all certificates into system directory files RHDS1 for LDAPS secure search.


 $ cp rootCA.crt /etc/openldap/certs/
 $ cp rootCA.crt /etc/pki/ca-trust/source/anchors/

=== Adding trusted root certificates to the server


 $ update-ca-trust extract

Edit /etc/openldap/ldap.conf, add TLS_CACERT and TLS_CACERTDIR.

 $ cat /etc/openldap/ldap.conf

         ADD TLS certs directory
           TLS_CACERT      /etc/openldap/certs/rootCA.crt
           TLS_CACERTDIR   /etc/openldap/certs/
      Comment the below line as we are not using kerbros
           #SASL_NOCANON   on

=== Copy the all certificates into system directory files RHDS2


  $ cp rootCA.crt /etc/openldap/certs/
  $ cp rootCA.crt /etc/pki/ca-trust/source/anchors/

=== Adding trusted root certificates to the server

  $ update-ca-trust extract

Edit /etc/openldap/ldap.conf, add TLS_CACERT and TLS_CACERTDIR.

  $cat /etc/openldap/ldap.conf
            ADD TLS certs directory
              TLS_CACERT      /etc/openldap/certs/rootCA.crt
              TLS_CACERTDIR   /etc/openldap/certs/
         Comment the below line as we are not using kerbros
              #SASL_NOCANON   on

=== validate the certificates uploaded into system

 $openssl crl2pkcs7 -nocrl -certfile /etc/pki/tls/certs/ca-bundle.crt | openssl pkcs7 -print_certs | grep subject | head


=== Import RHDS1 certificates
Import the server certificate into NSS databse for master-master replication over secure port.

TIP: FOR NSS database server password use token from pin.txt file
  $cat  /etc/dirsrv/slapd-rhds1/pin.txt
      Token: sadsfgdsjhrebsncvhdshfsdf

Import root certificte

 $certutil -d /etc/dirsrv/slapd-rhds1/ -A -n "Root CA" -t "CT,," -i /home/rootCA.crt

Import server certificte and key

  $dsctl rhds1 tls import-server-key-cert rhds1.crt rhds1.key

=== Enable secure port on RHDS instance

 $dsconf -D "cn=Directory Manager" ldap://rhds2.balic.in config replace nsslapd-securePort=636 nsslapd-security=on



=== Restart directory server for latest changes

 $systemctl restart dirsrv@rhds1.service

NOTE: rhds1 is instance name

===  List the NSS databse certificates

To get the list of imported certificates execute below command.

 $dsconf -D "cn=Directory Manager" ldap://rhds1.example.com -w12345678 security certificate list

NOTE: if output will appear your uploaded certificte name then ok otherwise there is something missing.

=== Validate the server uploaded with all certificates

 $openssl s_client --connect L7SRL2RDS01:636

=== Import RHDS2 certificates

Import the server certificate into NSS databse for master-master replication over secure port.

TIP: FOR NSS database server password use token from pin.txt file
  $cat  /etc/dirsrv/slapd-rhds2/pin.txt
      Token: sadsfgdsjhrebsncvhdshfsdf

Import root certificte

 $ certutil -d /etc/dirsrv/slapd-rhds2/ -A -n "Root CA" -t "CT,," -i /home/rootCA.crt

Import server certificte and key

  $ dsctl rhds2 tls import-server-key-cert rhds2.crt rhds2.key

=== Enable secure port on RHDS instance

  $ dsconf -D "cn=Directory Manager" ldap://rhds2.balic.in config replace nsslapd-securePort=636 nsslapd-security=on

=== Restart directory server for latest changes

 $systemctl restart dirsrv@rhds1.service

NOTE: rhds1 is instance name


=== List the NSS databse certificates

To get the list of imported certificates execute below command.

 $dsconf -D "cn=Directory Manager" ldap://rhds2.example.com -w12345678 security certificate list

=== Validate the server uploaded with all certificates using openssl s_client

 $openssl s_client --connect L7SRL2RDS02:636

=== Validate the ldap is searching with tls certificates

 $ldapsearch -D "cn=Directory Manager" -b "dc=bajajallianz,dc=in" ldaps://L7SRL2RDS01:636 -w12345678 -ZZ
     # extended LDIF
     # LDAPv3
     # base <dc=bajajallianz,dc=in> with scope subtree
     # filter: (objectclass=all)
     # requesting: ldaps://L7SRL2RDS01:636
     #
     # example.in
     dn: dc=bajajallianz,dc=in
     # people, example.in
     dn: ou=people,dc=bajajallianz,dc=in
     # search result
     search: 3
     result: 0 Success
     # numResponses: 3
    # numEntries: 2

 $ldapsearch -D "cn=Directory Manager" -b "dc=bajajallianz,dc=in" ldaps://L7SRL2RDS02:636 -w12345678 -ZZ

TIP: for debug mode search with -d option
 $ldapsearch -D "cn=Directory Manager" -b "dc=bajajallianz,dc=in" ldaps://L7SRL2RDS02:636 -w12345678 -ZZ -d 1


=== Create cluster configuration for master-master replication

==== On Master 2 RHDS2

Create DB if suffix is not available

  $dsconf -D "cn=Directory Manager" ldap://L7SRL2RDS01 -w "12345678" backend create --suffix="dc=bajajallianz,dc=in" --be-name="userRoot"
  $dsconf -D "cn=Directory Manager" ldap://L7SRL2RDS02 -w "12345678" backend create --suffix="dc=bajajallianz,dc=in" --be-name="userRoot"

Enable replication for the suffix, and create the replication manager account:

 $dsconf -D "cn=Directory Manager" -w "12345678" ldap://L7SRL2RDS02 replication enable --suffix="dc=bajajallianz,dc=in" --role="master" --replica-id=201 --bind-dn="cn=replication manager,cn=config" --bind-passwd="12345678"

=== On Master 1 RHDS1


Create Replication User and Replica-ID

  $dsconf -D "cn=Directory Manager" -w "12345678" ldap://L7SRL2RDS01 replication enable --suffix="dc=bajajallianz,dc=in" --role="master" --replica-id=202 --bind-dn="cn=replication manager,cn=config" --bind-passwd="12345678"

Create Replication Agreement on MASTER 1

  $dsconf -D "cn=Directory Manager" -w "12345678" ldap://L7SRL2RDS01 repl-agmt create --suffix="dc=bajajallianz,dc=in" --host="L7SRL2RDS02" --port=636 --conn-protocol=LDAPS --bind-dn="cn=replication manager,cn=config" --bind-passwd="12345678" --bind-method=SIMPLE --init repl-agreement-master1-to-master2

Verify replication

 $dsconf -D "cn=Directory Manager" -w "12345678" ldap://L7SRL2RDS01 repl-agmt init-status --suffix="dc=bajajallianz,dc=in" repl-agreement-master1-to-master2

=== Create replication agreement on Master 2

  $dsconf -D "cn=Directory Manager" -w "12345678" ldap://L7SRL2RDS02 repl-agmt create --suffix="dc=bajajallianz,dc=in" --host="L7SRL2RDS01" --port=636 --conn-protocol=LDAPS --bind-dn="cn=replication manager,cn=config" --bind-passwd="12345678" --bind-method=SIMPLE --init repl-agreement-master2-to-master1

Verify replication

  $dsconf -D "cn=Directory Manager" -w "12345678" ldap://L7SRL2RDS02 repl-agmt init-status --suffix="dc=bajajallianz,dc=in" repl-agreement-master2-to-master1

=== Verify Replication in RHDS1 on Webconsole

NOTE: Last init status initialized will show one time till then you will not restart the server. After restart it will show this message Not initialized. Replication will still work properly you can ignore this message.

image::rhds-replication-status.PNG[]


=== Verify Replication in RHDS2 on Webconsole


image::rhds2-replication-status.PNG[]

=== Add some user and groups to validate Replication

create OU in RHDS

 $cat addou.ldif
    dn: ou=People,dc=bajajallianz,dc=in
    objectClass: organizationalUnit
    ou: People
    dn: ou=groups,dc=bajajallianz,dc=in
    objectClass: organizationalUnit
    ou: groups
    dn: cn=eng,ou=groups,dc=bajajallianz,dc=in
    objectClass: groups
    cn: eng


 $cat adduser.ldif
    dn: uid=user-dev1,ou=People,dc=bajajallianz,dc=in
    objectClass: inetuser
    objectClass: organizationalPerson
    objectClass: person
    objectClass: top
    cn: user-dev1
    sn: user-dev1
    uid: user-dev1
    memberof: cn=eng,ou=Groups,dc=bajajallianz,dc=in

== Update Openshift-service-ca certifictes into RHSSO.
=== Create server certificate from openshift-service-ca rootCA.

Verify the signing-key certificate and key from openshift Service-ca project.

  $oc project openshift-service-ca
  $oc get secret signing-key -o yaml

i) Copy the certificate and key from signing-key secret into file.

  $ mkdir service-certs
  $ oc get secret signing-key -o yaml | grep "tls.crt: " | awk -F "tls.crt: " '{print $2}' | base64 -d  > tls.crt
  $ oc get secret signing-key -o yaml | grep "tls.key: " | awk -F "tls.key: " '{print $2}' | base64 -d  > tls.key
  $ ls
    tls.crt  tls.key

Verify the tls.key output with openssl.

      $openssl rsa -in tls.key -noout -text
      RSA Private-Key: (2048 bit, 2 primes)
      modulus:
          00:c6:e0:8e:b0:cb:0f:42:a4:13:e4:ee:c6:87:f0:
      publicExponent: 65537 (0x10001)
      privateExponent:
          1b:bd:34:89:da:38:cd:ad:bf:0c:9e:75:58:7e:9f:
          :fe:55:b3:96:ca:f1:e6:bc:
      prime1:
          00:ce:f8:96:6e:8b:7e:37:74:d5:cc:8c:fd:50:4b:
          b5:4f:8a:62:08:40:ef:50:02:4a:44:b9:66:ff:f5:
      prime2:
          00:f5:fd:21:74:9e:aa:67:b1:e9:3e:5c:1c:6a:1a:
          ba:f3:80:f8:3c:b3:ae:03:69:eb:85:6c:9f:e1:07:
      exponent1:
          00:b6:eb:4b:00:7e:36:59:ca:df:9d:fd:c9:6f:6a:
      exponent2:
          00:b0:10:ea:2d:4a:93:b5:7c:c5:f1:78:84:6d:fd:
          8b:ea:56:59:57:39:54:47:e5:3c:4a:57:a1:67:b3:
      coefficient:
          6c:ec:1c:ca:0f:09:6b:0f:b1:0a:52:fd:8a:f2:3c:

Verify the tls.crt Certificate using openssl. It should be signed by service-serving-signer.

    $openssl x509 -in tls.crt -noout -text
    Certificate:
        Data:
            Version: 3 (0x2)
            Serial Number: 328491252262512697 (0x48f090db2ee2839)
            Signature Algorithm: sha256WithRSAEncryption
            Issuer: CN = openshift-service-serving-signer@1589972358
            Validity
                Not Before: May 20 10:59:17 2020 GMT
                Not After : Jul 19 10:59:18 2022 GMT
            Subject: CN = openshift-service-serving-signer@1589972358
            Subject Public Key Info:
                Public Key Algorithm: rsaEncryption
                    RSA Public-Key: (2048 bit)
                    Modulus:
                        00:c6:e0:8e:b0:cb:0f:42:a4:13:e4:ee:c6:87:f0:
                    Exponent: 65537 (0x10001)
            X509v3 extensions:
                X509v3 Key Usage: critical
                    Digital Signature, Key Encipherment, Certificate Sign
                X509v3 Basic Constraints: critical
                    CA:TRUE
                X509v3 Subject Key Identifier:
                    36:EB:F6:44:90:F0:BD:27:53:B3:05:0E:1B:C1:66:8E:26:12:D6:0B
                X509v3 Authority Key Identifier:
                    keyid:36:EB:F6:44:90:F0:BD:27:53:B3:05:0E:1B:C1:66:8E:26:12:D6:0B
        Signature Algorithm: sha256WithRSAEncryption
             0d:f5:bc:b5:99:2e:64:f7:79:1c:2c:fb:c0:44:d0:6c:d5:31:


ii). Create KeyPair and store in Keystore. Provide redhat as the keystore password

  $keytool -genkeypair -keyalg RSA -keysize 2048 -dname "CN=*.apps.ocplife-np.bajajallianz.com" -alias rhsso -keystore keystore.jks -validity 730
  $Enter keystore password:
  $Re-enter new password:

iii). Generate the certificate sign request using keystore. Provide the same password (redhat).

  $keytool -certreq -keyalg rsa -alias rhsso -keystore keystore.jks -file sso.csr
  $Enter keystore password:


iv).Sign the Server Certificate by service signer CA. Provide redhat as the keystore password. Reply yes to Trust this certificate? [no]: question.

    $openssl x509 -req -CA tls.crt -CAkey tls.key -in sso.csr -out sso.crt -days 730 -CAcreateserial
    Signature ok
    subject=CN = *.apps.ocplife-np.bajajallianz.com
    Getting CA Private Key

v). Import the CA certificate into a new Red Hat Single Sign-On server truststore. Provide redhat as the truststore password. Reply yes to Trust this certificate? [no]: question:

    $keytool -import -file tls.crt -alias xpaas.ca -keystore truststore.jks
    $Enter keystore password:
    $Re-enter new password:

      output:
      Owner: CN=openshift-service-serving-signer@1589972358
      Issuer: CN=openshift-service-serving-signer@1589972358
      Serial number: 48f090db2ee2839
      Valid from: Wed May 20 16:29:17 IST 2020 until: Tue Jul 19 16:29:18 IST 2022
      Certificate fingerprints:
               SHA1: E0:95:0E:47:36:9A:26:C6:26:A1:61:BC:BA:D0:B6:6B:1E:D8:C3:09
               SHA256: 97:48:52:32:47:B1:2B:40:54:33:C5:45:9E:47:AE:D4:D9:EB:7A:ED:49:EC:D3:E4:DA:06:DC:AE:E4:0E:B2:AD
      Signature algorithm name: SHA256withRSA
      Subject Public Key Algorithm: 2048-bit RSA key
      Version: 3
      Extensions:
      #1: ObjectId: 2.5.29.35 Criticality=false
      AuthorityKeyIdentifier [
      KeyIdentifier [
      0000: 36 EB F6 44 90 F0 BD 27   53 B3 05 0E 1B C1 66 8E  6..D...'S.....f.
      0010: 26 12 D6 0B                                        &...
      ]
      ]
      #2: ObjectId: 2.5.29.19 Criticality=true
      BasicConstraints:[
        CA:true
        PathLen:2147483647
      ]
      #3: ObjectId: 2.5.29.15 Criticality=true
      KeyUsage [
        DigitalSignature
        Key_Encipherment
        Key_CertSign
      ]
      #4: ObjectId: 2.5.29.14 Criticality=false
      SubjectKeyIdentifier [
      KeyIdentifier [
      0000: 36 EB F6 44 90 F0 BD 27   53 B3 05 0E 1B C1 66 8E  6..D...'S.....f.
      0010: 26 12 D6 0B                                        &...
      ]
      ]
      Trust this certificate? [no]:  yes
      Certificate was added to keystore



vi). Import the server certificate into a new Red Hat Single Sign-On server truststore. Provide redhat as the truststore password. Reply yes to Trust this certificate? [no]: question:

    $keytool -import -file sso.crt -alias rhsso -keystore keystore.jks
    $Enter keystore password:
     Certificate reply was installed in keystore

vii). Generate a secure key for the JGroups keystore. Provide redhat as the keystore password.


    $keytool -genseckey -alias secret-key -storetype JCEKS -keystore jgroups.jceks
    $Enter keystore password:
    $Re-enter new password:
      Enter key password for <secret-key>
          (RETURN if same as keystore password):
      Re-enter new password:

=== Create the secrets
Create the secrets for the HTTPS and JGroups keystores. Truststore, generated in the previous steps.

      $oc create secret generic rhsso-secret2 --from-file=keystore.jks --from-file=jgroups.jceks --from-file=truststore.jks
      secret/rhsso-secret2 created

=== Link secret to your project
Link these secrets to the default service account, which is used to run Red Hat Single Sign-On pods.

      $oc secrets link default rhsso-secret2

=== Update secret into RHSSO deployment-config for certificte update.
Replace the rhsso-secret with rhsso-secret2 in rhsso-np deploymentconfig.

   $oc edit dc rhsso-np
[source,yaml]
----
spec:
      containers:
      - env:
value: rhsso-secret2
       - name: JGROUPS_ENCRYPT_KEYSTORE_DIR
volumes:
     - name: eap-keystore-volume
       secret:
         defaultMode: 420
         secretName: rhsso-secret2
     - name: eap-jgroups-keystore-volume
       secret:
         defaultMode: 420
         secretName: rhsso-secret2
     - name: sso-truststore-volume
       secret:
         defaultMode: 420
         secretName: rhsso-secret2
----

== RHSSO user authentication using kerberos.
For kerberos password authentication the following steps need to be followed.

=== Create PV for kerberos-conf and keytab file storage.
One persistent storage is needed to add the Kerberos custom configuration file and keytab file inside rhsso pods.

[source,yaml]
----
$ cat rhsso-pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: rhsso-pv
spec:
  capacity:
    storage: 3Gi
  storageClassName: manual
  accessModes:
  - ReadWriteMany
  nfs:
    path: /ssokerberos
    server: 172.20.99.222
  persistentVolumeReclaimPolicy: Retain

----

  $oc apply -f sso-pvc.yaml
   persistentvolume/rhsso-pv created

=== Create new pvc from rhsso pv

[source,yaml]
----
cat sso-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: rhsso-kerberos
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi
  volumeName: rhsso-pv
  storageClassName: manual
----

  $oc apply -f sso-pvc.yaml
   persistentVolumeClaim/rhsso-kerberos created

=== Edit kerberos configuration file inside the rhsso pod.
Copy kerberos configuration file outside from RHSSO any pod to add the Active Directory realm name into krb.conf. This file need to be copied into rhsso pod in later stage.

  $oc get pods
  $oc exec sso-25-gnt2q cat /etc/krb5.conf  > krb5.conf

=== Add Realm name and domain realm into custom configuration File and remove uncommeneted lines from the file.

NOTE: As of now /etc/kbr5.conf file is used by the rhsso but for custom changes add a new .conf file into /etc/krb5.conf.d/ directory and we can do custom configuration for kerberos realm.

[source,yaml]
----
$cat krb5.conf
# To opt out of the system crypto-policies configuration of krb5, remove the
# symlink at /etc/krb5.conf.d/crypto-policies which will not be recreated.
[libdefaults]
    default_realm = BAJAJALLIANZ.IN
    default_tkt_enctypes = aes256-cts-hmac-sha1-96 aes256-cts aes128-cts-hmac-sha1-96 aes128-cts rc4-hmac des3-cbc-sha1 des-cbc-md5 des-cbc-crc arcfour-hmac-md5 arcfour-hmac
    default_tgs_enctypes = aes256-cts-hmac-sha1-96 aes256-cts aes128-cts-hmac-sha1-96 aes128-cts rc4-hmac des3-cbc-sha1 des-cbc-md5 des-cbc-crc arcfour-hmac-md5 arcfour-hmac
    permitted_enctypes   = aes256-cts-hmac-sha1-96 aes256-cts aes128-cts-hmac-sha1-96 caes128-cts rc4-hmac des3-cbc-sha1 des-cbc-md5 des-cbc-crc arcfour-hmac-md5 arcfour-hmac
    dns_lookup_realm = false
    dns_lookup_kdc = false
    dns_canonicalize_hostname = false
    ignore_acceptor_hostname = true
    forwardable = true
    default_ccache_name = KEYRING:persistent:%{uid}

[realms]
 BAJAJALLIANZ.IN = {
     kdc = l7srw2adc01.bajajallianz.in
     admin_server = l7srw2adc01.bajajallianz.in
 }

[domain_realm]
 .bajajallianz.in = BAJAJALLIANZ.IN
 bajajallianz.in = BAJAJALLIANZ.IN
----


=== Add volume mount path to /tmp/sso directory.

To attach the storage to rhsso pod, first need to attach it to some other location in deployment config directory otherwise it will not be able to attach to exact storage path.

Edit deployment config and add the following properties into deployment configuration.

 $oc edit dc rhsso-np
[source,yaml]
----
  volumeMounts:
   ..............
   - mountPath: /tmp/sso
     name: rhsso-kerberos

   volumes:
   .........
   - name: rhsso-kerberos
     persistentVolumeClaim:
       claimName: rhsso-kerberos
----

=== Copy the kerberos default configuration content into mount directory.
Login into rhsso pod and copy the all content /etc/krb5.conf.d/ content into /tmp/sso directory

  oc rsh sso-26-g4gpx
  $ cp /etc/krb5.conf.d/  /tmp/sso/

NOTE: logout from the pod now. All content of /etc/krb5.conf.d/ are in pvc.

=== Edit the deployment config and replace the /tmp/sso storage with Kerberos config directory.
Replace the /tmp/sso path to /etc/krb5.conf.d/ in rhsso-kerberos volumeMounts in rhsso deploymentconfig.

 $oc edit dc rhsso-np

[source=yaml]
----
  volumeMounts:
   ..............
  - mountPath: /etc/krb5.conf.d/
   name: rhsso-kerberos
----

=== copy the keytab file and krb5.conf into RHSSO pod

  $oc cp krb5.conf sso-26-g4gpx:/etc/krb5.conf.d/
  $oc cp krb1.keytab sso-26-g4gpx:/etc/krb5.conf.d/


=== Rebuild the RHSSO image with custom Kerberos configuration file
Add Kerberos conf property in extensions cli to load the configuration on Jboss start up.

  $ cat sso-extensions.cli
  /system-property=java.security.krb5.conf:add(value=/etc/krb5.conf.d/abc.conf)


NOTE: sso-extensions.cli file is already created in previous step. (7.4.4.7. Create RHSSO configuration for datasource, caches and RHDG connectivity using cli commands.)


Rebuild the image with oc start build.

  $oc start-build sso74 --from-dir=rhsso --follow -n openshift

=== Add Kerberos configuration in ldap user federation.
Below configuration need to be done in Kerberos integration.

1) Allow Kerberos authentication: ON

2) Kerberos Realm: BAJAJALLIANZ.IN

3) Server Principal: HTTP/secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com@BAJAJALLIANZ.IN

4) keytab: /etc/krb5.conf.d/krb5.conf

5) Use Kerberos for password authentication: ON

NOTE: (Use Kerberos for password authentication is optional. If every user is Kerberos authenticated then enable it otherwise disable it)

image::ldap-federation.png[]
==== ldap Username Mapper
Replace LDAP attribute from cn to SamAccountName username mapper because kerberos identifies the username without space (rhsso.admin).

LDAP attribute:  SamAccountName

image::username-mapper.png[]

==== ldap  Group mapper
In Group mapper change the Memebership User LDAP Attribute for users group mapping.

Memebership User LDAP Attribute:  SamAccountName

image::group-mapper.png[]

=== Application testing in AD client machine
Add kerberos configuration in every browser to trust the local intranet and websites.

==== Mozilla Firefox
1) Open the low level Firefox configuration page by loading the about:config page.

2) In the Search text box, enter: network.negotiate-auth.trusted-uris

3) Double-click the network.negotiate-auth.trusted-uris preference and enter the sso url https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com.

4) Click Ok.

==== Internet Explorer

Follow the steps below to configure Internet Explorer.

1) Configuring the Local Intranet Domain

2) Open Internet Explorer and click the Settings gear icon in the top-right corner. Select Internet options.

3) Select the Security tab.

4) Select the Local Intranet zone and click the Sites button.

5) Make sure that the first two options, Include all local (intranet) sites not listed in other zones and Include all sites that bypass the proxy server are checked.

6) Click Advanced and add the names of the domains that are protected by Kerberos HTTP SPNEGO, one at a time, to the list of websites. For example,https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com  Click Close.

7) Click OK to save your configuration changes.

===== Configuring Intranet Authentication
1) Click the Settings gear icon in the top-right corner. Select Internet options.

2) Select the Security tab.

3) Select the Local Intranet zone and click the Custom level... button to open the Security Settings - Local Intranet Zone dialog box.

4) Scroll down to the User Authentication options and select Automatic logon only in Intranet zone.

5) Click OK to save these changes.

===== Google Chrome
For Windows:
Open the Control Panel to access the Internet Options dialog. Use the same configuration as detailed in Configuration changes required are the same as those described above for Internet Explorer.

== 3Scale API authentication with RHSSO.
3scale can synchronize client credentials between 3scale (Application credentials) and a Red Hat Single Sign-On server using OpenID Connect (OIDC). 3scale utilizes a service called Zync to synchronize calls to the Red Hat Single Sign-On server.

=== Create 3scale client in RHSSO

1). Create client in rhsso for 3scale authentication.

 Client Name: 3scale-sso
 CLient protocol: open-id connect
 Access Type: confidential
 Service Accounts Enabled: ON
 Authorization Enabled: ON

image::3scale-client-conf.PNG[]

2) Assign management role to clients.

 Client roles: relam-management
 Assign Role: manage-clients

image::client_roles.png[]

3) Copy client secret for 3scale OIDC configuration. This will be used in 3scale for openID connect issue.

image::3scale-client-credentials.PNG[]

=== Configure Zync to use custom CA certificates

To establish the SSL connection between Zync and Red Hat Single Sign-On. Custom CA certificates for Red Hat Single Sign-On with the SSL_CERT_FILE environment variable. This variable points to the local path of the certificates bundle. Configure it as follows.

1) Copy sso certificate into file.
$echo -n | openssl s_client -connect secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com:443 -showcerts| sed -ne '/BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'>sso.pem

depth=1 CN = xpaas-sso.ca
verify error:num=19:self signed certificate in certificate chain
verify return:1
depth=1 CN = xpaas-sso.ca
verify return:1
depth=0 CN = secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com
verify return:1
DONE

Validate the new certificate with the following cURL command. The expected response is a JSON configuration of the realm. If validation fails it is an indicator that your certificate may not be correct.

    $curl -k https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com:443 -cacert sso.pem


2) Add the certificate bundle to the Zync-que pod:

Copy existing content of the /etc/pki/tls/cert.pem file on the Zync-que pod. Run:

 $oc exec zync-que-3-m5stl cat /etc/pki/tls/zync/zync.pem

3) Append the contents of the custom CA certificate file to zync.pem:

 $cat customCA.pem >> zync.pem

4) Attach the new file to the Zync pod as ConfigMap:

    $oc create configmap zync-ca-bundle --from-file=./zync.pem

5) Assign storage to zync-que dc

    $oc set volume dc/zync-que --add --name=zync-que-ca-bundle --mount-path /etc/pki/tls/zync/zync-que.pem --sub-path zync-que.pem --source='{"configMap"
    :{"name":"zync-que-ca-bundle","items":[{"key":"zync-que.pem","path":"zync-que.pem"}]}}'
    deploymentconfig.apps.openshift.io/zync-que volume updated

Verify that the certificate is attached and the content is correct:

    $oc exec zync-que-ca-bundle cat /etc/pki/tls/zync/zync-que.pem > zync1.pem


   $curl "https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/master" --cacert zync1.pem
    {"realm":"master","public_key":"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjotwKKyOs/FmMWK6+E7eQC3FCf3ZxcsyOv3oOFXHhoVszneXQmqpvwRMK/GDzJHR3Bimg6XcPO5KojWIOonniBgXYj+gg7EN/CMlHbiR1D4tN6gQWgTJ1g+yi2oJt1BNH5Usne62se3d8bHDfyAm0NBbVGnmXcMVvY175J5VTGsRGNMGfvE3qur7/hVdHGhP1Ku9nOf9cumTTS/Zs0H9ITsSe0SwsN/DpOhqRqaXGJMaVhs7h+M6iTA+vdgow+QGIDhib8peozpdeus8yEiaCgDgog9F7MMt7XThEmrpkaeq5kab3w4bGiQsUrniu8ZsBQ/p8+znFijjkHXzpV+eLwIDAQAB","token-service":"https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/master/protocol/openid-connect","account-service":"https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/master/account","tokens-not-before":0}root@LAPTOP-S928577R:~#

     $curl https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/master --cacert zync1.pem
    {"realm":"master","public_key":"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjotwKKyOs/FmMWK6+E7eQC3FCf3ZxcsyOv3oOFXHhoVszneXQmqpvwRMK/GDzJHR3Bimg6XcPO5KojWIOonniBgXYj+gg7EN/CMlHbiR1D4tN6gQWgTJ1g+yi2oJt1BNH5Usne62se3d8bHDfyAm0NBbVGnmXcMVvY175J5VTGsRGNMGfvE3qur7/hVdHGhP1Ku9nOf9cumTTS/Zs0H9ITsSe0SwsN/DpOhqRqaXGJMaVhs7h+M6iTA+vdgow+QGIDhib8peozpdeus8yEiaCgDgog9F7MMt7XThEmrpkaeq5kab3w4bGiQsUrniu8ZsBQ/p8+znFijjkHXzpV+eLwIDAQAB","token-service":"https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/master/protocol/openid-connect","account-service":"https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/master/account","tokens-not-before":0}root@LAPTOP-S928577R:~# curl https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/master --cacert zync1.pem |jq
      % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                     Dload  Upload   Total   Spent    Left  Speed
    100   678  100   678    0     0   1530      0 --:--:-- --:--:-- --:--:--  1530
    {
      "realm": "master",
      "public_key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjotwKKyOs/FmMWK6+E7eQC3FCf3ZxcsyOv3oOFXHhoVszneXQmqpvwRMK/GDzJHR3Bimg6XcPO5KojWIOonniBgXYj+gg7EN/CMlHbiR1D4tN6gQWgTJ1g+yi2oJt1BNH5Usne62se3d8bHDfyAm0NBbVGnmXcMVvY175J5VTGsRGNMGfvE3qur7/hVdHGhP1Ku9nOf9cumTTS/Zs0H9ITsSe0SwsN/DpOhqRqaXGJMaVhs7h+M6iTA+vdgow+QGIDhib8peozpdeus8yEiaCgDgog9F7MMt7XThEmrpkaeq5kab3w4bGiQsUrniu8ZsBQ/p8+znFijjkHXzpV+eLwIDAQAB",
      "token-service": "https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/master/protocol/openid-connect",
      "account-service": "https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/master/account",
      "tokens-not-before": 0
    }


6) Configure the SSL_CERT_FILE environment variable on Zync to point to the new CA certificate bundle:

    $oc set env dc/zync-que SSL_CERT_FILE=/etc/pki/tls/zync/zync.pem
    deploymentconfig.apps.openshift.io/zync updated


     $oc exec zync-que-3-m5stl cat /etc/pki/tls/zync/zync.pem
    -----BEGIN CERTIFICATE-----
    MIID3TCCAcUCFDjlRLeKYHlMXd5GMUHA0452TPZZMA0GCSqGSIb3DQEBCwUAMBcx
    FTATBgNVBAMMDHhwYWFzLXNzby5jYTAeFw0yMDA3MDMwNzA0MTRaFw0yMTA3MDMw
    NzA0MTRaMD8xPTA7BgNVBAMTNHNlY3VyZS1zc28tcmhzc28tbnAuYXBwcy5vY3Bs
    aW
    -----END CERTIFICATE-----
    -----BEGIN CERTIFICATE-----
    MIIFDzCCAvegAwIBAgIUZkjQ8/D0gW9IUNny74y5MPbl13MwDQYJKoZIhvcNAQEL
    BQAwFzEVMBMGA1UEAwwMeHBhYXMtc3NvLmNhMB4XDTIwMDcwMzA2NTY0MloXDTIx
    MDcwMzA2NTY
    RBQw
    -----END CERTIFICATE-----

==== Configure 3scale

To configure 3scale, take the following steps:

Enable OpenID Connect.

image::3scale-openid-selection.PNG[]

Under the Authentication Settings heading, in the OpenID Connect Issuer field, enter the previously copied client credentials  from 3scale-sso with the URL of Red Hat Single Sign-On server.

https://3scale-sso:abc4rhs-56gs-4hsku-jok23@secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com:8443/auth/realms/internal


Select OIDC authorization flow

 *Check Authorization flow
 *Check Service accounts

image::3scale-oidc.PNG[]

Select the service on which you want to enable the OpenID Connect authentication (in this setup pincode API has been used), navigate to settings > Integration > Configuration.

To save the configuration, click Update the Staging Environment.

image::3scale-promote.PNG[]

Add API Credentials
Edit redirect URL and add 3scale staging url.

image::3scale-redirect-url.PNG[]

Verify the client is added or not.

image::3scale-client.PNG[]


==== Test the 3scale API with RHSSO.

Request to access the token from RHSSO

  $curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -H "Accept:application/json" -d "grant_type=client_credentials&redirect_uri=https:
  //secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/internal/protocol/openid-connect/auth&client_id=eba1360f&client_secret=abb42c53b34cec00dcf86733a8253b97"
  https://secure-sso-rhsso-np.apps.ocplife-np.bajajallianz.com/auth/realms/internal/protocol/openid-connect/token

Curl response

 {"access_token":"qMkdY.................","token_type":"bearer","not-before-policy":0,"session_state":"08bc2756-3f9b-4403-bdc6-b1ff2c531d89","scope":"email profile"}


Request to 3 scale API with SSO token. Copy the access token and hit the application with 3scale API staging URL.

 $curl -vv -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiAzQ3KLXT06mKizLipY7TDd_tPdVyuVAKhtmNOx2uK4PKWBOVFydx3vfmbYaSKUi9lyrGd9jaw"  "https://pinecode-3scale-apicast-staging.apps.ocplife-np.bajajallianz.com:443/?app_id=eba1360f&app_key=abb42c53b34cec00dcf86733a8253b97"
    *   Trying 172.20.98.180:443...
    * TCP_NODELAY set
    * Connected to pinecode-3scale-apicast-staging.apps.ocplife-np.bajajallianz.com (172.20.98.180) port 443 (#0)
    * ALPN, offering h2
    * ALPN, offering http/1.1
    * successfully set certificate verify locations:
    *   CAfile: /etc/ssl/certs/ca-certificates.crt
      CApath: /etc/ssl/certs
    * TLSv1.3 (OUT), TLS handshake, Client hello (1):
    * TLSv1.3 (IN), TLS handshake, Server hello (2):
    * TLSv1.2 (IN), TLS handshake, Certificate (11):
    * TLSv1.2 (IN), TLS handshake, Server key exchange (12):
    * TLSv1.2 (IN), TLS handshake, Server finished (14):
    * TLSv1.2 (OUT), TLS handshake, Client key exchange (16):
    * TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):
    * TLSv1.2 (OUT), TLS handshake, Finished (20):
    * TLSv1.2 (IN), TLS handshake, Finished (20):
    * SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256
    * ALPN, server did not agree to a protocol
    * Server certificate:
    *  subject: C=IN; ST=Maharashtra; L=PUNE; O=BAJAJ ALLIANZ LIFE INSURANCE COMPANY LIMITED; CN=*.apps.ocplife-np.bajajallianz.com
    *  start date: Aug 27 00:00:00 2020 GMT
    *  expire date: Jul 31 12:00:00 2021 GMT
    *  subjectAltName: host "pinecode-3scale-apicast-staging.apps.ocplife-np.bajajallianz.com" matched cert's "*.apps.ocplife-np.bajajallianz.com"
    *  issuer: C=US; O=DigiCert Inc; OU=www.digicert.com; CN=GeoTrust RSA CA 2018
    *  SSL certificate verify ok.
    > GET /?app_id=eba1360f&app_key=abb42c53b34cec00dcf86733a8253b97 HTTP/1.1
    > Host: pinecode-3scale-apicast-staging.apps.ocplife-np.bajajallianz.com
    > User-Agent: curl/7.68.0
    > Accept: */*
    > Authorization: Bearer
    Mark bundle as not supporting multiuse
    < HTTP/1.1 200 OK
    < Server: openresty
    < Date: Fri, 04 Sep 2020 13:32:03 GMT
    < Content-Type: text/html
    < Content-Length: 0
    < x-xss-protection: 1; mode=block
    < X-Frame-Options: DENY
    < Last-Modified: Thu, 29 Aug 2019 12:26:50 GMT
    < ETag: "0-591409eb72205"
    < Accept-Ranges: bytes
    < Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
    < X-Content-Type-Options: nosniff
    < Content-Security-Policy: default-src 'self';
    < Set-Cookie: Per=ffffffff090b1a5845525d5f4f58455e445a4a422851;expires=Fri, 04-Sep-2020 13:47:03 GMT;path=/;secure;httponly
    < Set-Cookie: 991d60de1c7c53766545c1485a6b57d7=486a7b52dfa25f44255bfacadbb4aecb; path=/; HttpOnly; Secure
    < Cache-control: private
    <
    * Connection #0 to host pinecode-3scale-apicast-staging.apps.ocplife-np.bajajallianz.com left intact
